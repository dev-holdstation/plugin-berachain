{"version":3,"sources":["../src/actions/swapAction.ts","../src/templates/swapTemplate.ts","../src/templates/transferTemplate.ts","../src/providers/walletProvider.ts","../src/environment.ts","../src/constants/index.ts","../src/actions/transferAction.ts","../src/index.ts"],"sourcesContent":["import {\n    type Action,\n    type IAgentRuntime,\n    type Memory,\n    type HandlerCallback,\n    type State,\n    composeContext,\n    ModelClass,\n    elizaLogger,\n    type ActionExample,\n    generateObjectDeprecated,\n} from \"@elizaos/core\";\n\nimport { swapTemplate } from \"../templates\";\nimport type { SendTransactionParams, SwapParams, SwapResult } from \"../types\";\nimport {\n    initWalletProvider,\n    type WalletProvider,\n} from \"../providers/walletProvider\";\nimport { validateBerachainConfig } from \"../environment\";\nimport { HOLDSTATION_ROUTER_ADDRESS, NATIVE_ADDRESS } from \"../constants\";\nimport { parseUnits, type Hex } from \"viem\";\n\n// ------------------------------------------------------------------------------------------------\n// Core Action Class\n// ------------------------------------------------------------------------------------------------\nexport class SwapAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async swap(params: SwapParams): Promise<SwapResult> {\n        const { items: tokens } = await this.walletProvider.fetchPortfolio();\n\n        if (!params.inputTokenCA && !params.inputTokenSymbol) {\n            throw new Error(\"Input token not provided\");\n        }\n\n        const filters = tokens.filter((t) => {\n            return params.inputTokenCA\n                ? t.address === params.inputTokenCA\n                : t.symbol === params.inputTokenSymbol?.toUpperCase();\n        });\n        if (filters.length !== 1) {\n            throw new Error(\n                \"Multiple tokens or no tokens found with the symbol\"\n            );\n        }\n\n        // fill in token info\n        params.inputTokenCA = filters[0].address;\n        params.inputTokenSymbol = filters[0].symbol;\n        const decimals = filters[0].decimals ?? 18;\n\n        // parse amount out\n        const tokenAmount = parseUnits(params.amount, decimals);\n\n        if (!params.outputTokenCA && !params.outputTokenSymbol) {\n            throw new Error(\"Output token not provided\");\n        }\n\n        if (!params.outputTokenCA || !params.outputTokenSymbol) {\n            const tokens = await this.walletProvider.fetchAllTokens();\n            const filters = tokens.filter((t) => {\n                return params.outputTokenCA\n                    ? t.address === params.outputTokenCA\n                    : t.symbol === params.outputTokenSymbol?.toUpperCase();\n            });\n            if (filters.length !== 1) {\n                throw new Error(\n                    \"Multiple tokens or no tokens found with the symbol\"\n                );\n            }\n            params.outputTokenCA = filters[0].address;\n            params.outputTokenSymbol = filters[0].symbol;\n        }\n\n        elizaLogger.info(\"--- Swap params:\", params, tokenAmount);\n\n        // fetch swap tx data\n        const walletAddress = this.walletProvider.getAddress();\n        const deadline = Math.floor(Date.now() / 1000) + 10 * 60;\n        const swapUrl = `https://swap.hold.so/berachain/api/swap?src=${params.inputTokenCA}&dst=${params.outputTokenCA}&amount=${tokenAmount}&receiver=${walletAddress}&deadline=${deadline}`;\n        elizaLogger.info(\"swapUrl:\", swapUrl);\n        const swapResponse = await fetch(swapUrl);\n        const swapData = await swapResponse.json();\n        if (!swapData || swapData.error) {\n            elizaLogger.error(\"Swap error:\", swapData);\n            throw new Error(\n                `Failed to fetch swap: ${swapData?.error || \"Unknown error\"}`\n            );\n        }\n\n        // generate nonce\n        const nonce = await this.walletProvider.getNonce();\n\n        const populatedTx: SendTransactionParams = {\n            to: HOLDSTATION_ROUTER_ADDRESS,\n            data: swapData.tx.data,\n            nonce: nonce,\n        };\n\n        if (\n            params.inputTokenCA.toLowerCase() !== NATIVE_ADDRESS.toLowerCase()\n        ) {\n            const allowance = await this.walletProvider.getAllowace(\n                params.inputTokenCA,\n                HOLDSTATION_ROUTER_ADDRESS\n            );\n            if (allowance < tokenAmount) {\n                await this.walletProvider.approve(\n                    HOLDSTATION_ROUTER_ADDRESS,\n                    params.inputTokenCA,\n                    tokenAmount\n                );\n            }\n        } else {\n            populatedTx.value = tokenAmount;\n        }\n\n        const hash = await this.walletProvider.sendTransaction(populatedTx);\n\n        return {\n            hash: hash as Hex,\n            ...params,\n        };\n    }\n}\n\n// ------------------------------------------------------------------------------------------------\n// Core Action Implementation\n// ------------------------------------------------------------------------------------------------\nexport const swapAction: Action = {\n    name: \"TOKEN_SWAP\",\n    description: \"Perform swapping of tokens on Berachain by HoldStation swap.\",\n    similes: [\n        \"SWAP_TOKEN\",\n        \"TOKEN_SWAP_ON_BERACHAIN\",\n        \"EXCHANGE_TOKENS\",\n        \"EXCHANGE_TOKENS_ON_BERACHAIN\",\n        \"CONVERT_TOKENS\",\n        \"CONVERT_TOKENS_ON_BERACHAIN\",\n    ],\n    validate: async (\n        runtime: IAgentRuntime,\n        _message: Memory\n    ): Promise<boolean> => {\n        await validateBerachainConfig(runtime);\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting Berachain TOKEN_SWAP handler...\");\n\n        const walletProvider = await initWalletProvider(runtime);\n        const action = new SwapAction(walletProvider);\n\n        // Initialize or update state\n        let currentState =\n            state ?? ((await runtime.composeState(message)) as State);\n        if (state) {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // compose swap context\n        const swapContext = composeContext({\n            state: currentState,\n            template: swapTemplate,\n        });\n\n        // generate swap content\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: swapContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        elizaLogger.info(\"generate swap content:\", content);\n\n        try {\n            const {\n                hash,\n                inputTokenCA,\n                inputTokenSymbol,\n                outputTokenCA,\n                outputTokenSymbol,\n                amount,\n            } = await action.swap(content);\n\n            const successMessage = `Swap completed successfully from ${amount} ${inputTokenSymbol} (${inputTokenCA}) to ${outputTokenSymbol} (${outputTokenCA})!\\nTransaction Hash: ${hash}`;\n            elizaLogger.success(successMessage);\n\n            callback?.({\n                text: successMessage,\n                content: {\n                    success: true,\n                    hash: hash,\n                },\n            });\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error during token swap:\", error);\n            const errorMessage =\n                error instanceof Error ? error.message : \"Unknown error\";\n\n            callback?.({\n                text: `Error during token swap: ${errorMessage}`,\n                content: { error: errorMessage },\n            });\n\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Swap 100 USDC for BERA\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Sure, I'll do swap 100 USDC for BERA now.\",\n                    action: \"TOKEN_SWAP\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Swap completed 100 USDC for BERA successfully! Transaction: ...\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n","export const swapTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\nHere are several frequently used addresses. Use these for the corresponding tokens:\n- BERA/bera: 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n- ETH/eth: 0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590\n- USDCe/usdc.e: 0x549943e04f40284185054145c6E4e9568C1D3241\n- HOLD/hold: 0xFF0a636Dfc44Bb0129b631cDd38D21B613290c98\n- HONEY/honey: 0xFCBD14DC51f0A4d49d5E53C2E0950e0bC26d0Dce\n\nExample response:\n\\`\\`\\`json\n{\n    \"inputTokenSymbol\": \"HOLD\",\n    \"outputTokenSymbol\": \"BERA\",\n    \"inputTokenCA\": \"0xFF0a636Dfc44Bb0129b631cDd38D21B613290c98\",\n    \"outputTokenCA\": \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\",\n    \"amount\": \"50\",\n    \"slippage\": \"0.005\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nGiven the recent messages and wallet information below:\n\n{{account}}\n\nExtract the following information about the requested token swap:\n- Input token symbol (the token being sold)\n- Output token symbol (the token being bought)\n- Input token contract address\n- Output token contract address\n- Amount to swap\n- Slippage tolerance (optional, default 0.005 if not specified)\n\n**Validation Details**:\n1. **Amount**:\n   - Verify the amount is a valid numeric string.\n\n2. **Input and Output Tokens**:\n   - Verify that atleast one of the symbol or contract address is provided for both input and output tokens.\n\n3. **Slippage**:\n   - If the user does not specify, use the default value of 0.5%.\n\n**Example Scenarios**:\n1. User says, \"Swap 1 HOLD for BERA\":\n   - Input token symbol: HOLD\n   - Output token symbol: BERA\n   - Input token contract address: null\n   - Output token contract address: null\n   - Amount to swap: 1\n   - Slippage: null (default will apply)\n\n2. User says, \"Swap 4 USDCe to BERA (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) with 1% slippage\":\n   - Input token symbol: USDCe\n   - Output token symbol: BERA\n   - Input token contract address: null\n   - Output token contract address: 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n   - Amount to swap: 4\n   - Slippage: 0.01\n\n3. User says, \"Swap 1 token CA 0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590 to BERA with 0.5% slippage\":\n    - Input token symbol: null\n    - Output token symbol: BERA\n    - Input token contract address: 0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590\n    - Output token contract address: null\n    - Amount to swap: 1\n    - Slippage: 0.005\n\nNow, process the user's request and provide the JSON response.`;\n","export const transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\nHere are several frequently used addresses. Use these for the corresponding tokens:\n- BERA/bera: 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n- ETH/eth: 0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590\n- USDCe/usdc.e: 0x549943e04f40284185054145c6E4e9568C1D3241\n- HOLD/hold: 0xFF0a636Dfc44Bb0129b631cDd38D21B613290c98\n- HONEY/honey: 0xFCBD14DC51f0A4d49d5E53C2E0950e0bC26d0Dce\n\nExample response:\n\\`\\`\\`json\n{\n    \"inputTokenSymbol\": \"HOLD\",\n    \"inputTokenCA\": \"0xFF0a636Dfc44Bb0129b631cDd38D21B613290c98\",\n    \"amount\": \"50\",\n    \"recipient\": \"0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nGiven the recent messages and wallet information below:\n\n{{account}}\n\nExtract the following information about the requested token swap:\n- Input token symbol (the token being transferred)\n- Input token contract address\n- Amount to transfer\n- Recipient address (the address to receive the tokens) \n\n**Validation Details**:\n1. **Amount**:\n   - Verify the amount is a valid numeric string.\n\n2. **Input Tokens**:\n   - Verify that atleast one of the symbol or contract address is provided.\n\n3. **Recipient Address**:\n   - Verify that the recipient address is a valid Ethereum address.\n\n**Example Scenarios**:\n1. User says, \"Send 1 HOLD to address 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\":\n   - Input token symbol: HOLD\n   - Input token contract address: null\n   - Amount to transfer: 1\n   - Recipient address: 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\n\n2. User says, \"Transfer 50 BERA (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) to address 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\":\n   - Input token symbol: BERA\n   - Input token contract address: 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n   - Amount to transfer: 50\n   - Recipient address: 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\n\nNow, process the user's request and provide the JSON response.`;\n","import {\n    type Provider,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\n\nimport type {\n    Item,\n    PortfolioItem,\n    SendTransactionParams,\n    TokenApiItem,\n    WalletPortfolio,\n    WalletProviderResponse,\n} from \"../types\";\n\nimport NodeCache from \"node-cache\";\nimport { Address, erc20Abi, Hex } from \"viem\";\nimport { ethers, Wallet } from \"ethers\";\n\nexport class WalletProvider {\n    private cache: NodeCache;\n    private wallet: Wallet;\n\n    constructor(privateKey: string, rpcUrl: string) {\n        this.cache = new NodeCache({ stdTTL: 300 });\n\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        this.wallet = new Wallet(privateKey, provider);\n    }\n\n    getAddress() {\n        return this.wallet.address;\n    }\n\n    getNonce() {\n        return this.wallet.getNonce();\n    }\n\n    async getAllowace(\n        tokenAddress: Address,\n        spender: Address\n    ): Promise<bigint> {\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            this.wallet\n        );\n        return erc20Contract.allowance(this.getAddress(), spender);\n    }\n\n    async approve(\n        spenderAddress: Address,\n        tokenAddress: Address,\n        amount: bigint\n    ) {\n        const erc20Contract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            this.wallet\n        );\n        const tx = await erc20Contract.approve(spenderAddress, amount);\n        await tx.wait();\n    }\n\n    async sendTransaction(req: SendTransactionParams): Promise<string> {\n        const txResp = await this.wallet.sendTransaction(req);\n        console.log(\"sendTransaction txhash:\", txResp.hash);\n        return txResp.hash;\n    }\n\n    async transfer(\n        tokenAddress: Address,\n        amount: bigint,\n        recipient: Address\n    ): Promise<Hex> {\n        const tokenContract = new ethers.Contract(\n            tokenAddress,\n            erc20Abi,\n            this.wallet\n        );\n        const nonce = await this.wallet.getNonce();\n        const tx = await tokenContract.transfer(recipient, amount, { nonce });\n        const receipt = await tx.wait();\n        return receipt.hash;\n    }\n\n    async fetchPortfolio(): Promise<WalletPortfolio> {\n        try {\n            const cacheKey = `portfolio-${this.getAddress()}`;\n            const cachedValue = this.cache.get<WalletPortfolio>(cacheKey);\n            if (cachedValue) {\n                elizaLogger.info(\"Cache hit for fetchPortfolio\");\n                return cachedValue;\n            }\n            elizaLogger.info(\"Cache miss for fetchPortfolio\");\n\n            const fetchUrl = `https://api.holdstation.com/api/user-balance/chain/80094/wallet/${this.getAddress()}`;\n\n            const portfolioResp = await fetch(fetchUrl);\n            const portfolioData = await portfolioResp.json();\n            if (!portfolioData || !portfolioData.success) {\n                elizaLogger.error(\"Failed to fetch portfolio:\", portfolioData);\n                throw new Error(\n                    `Failed to fetch portfolio: ${\n                        portfolioData?.error || \"Unknown error\"\n                    }`\n                );\n            }\n\n            const items: Array<Item> =\n                portfolioData.data.map(\n                    (item: PortfolioItem): Item => ({\n                        name: item.contract_name,\n                        address: item.contract_address.startsWith(\"0x\")\n                            ? (item.contract_address as `0x${string}`)\n                            : (`0x${item.contract_address}` as `0x${string}`),\n                        symbol: item.contract_ticker_symbol,\n                        decimals: item.contract_decimals,\n                    })\n                ) || [];\n            const portfolio: WalletPortfolio = { items };\n\n            this.cache.set(cacheKey, portfolio);\n            return portfolio;\n        } catch (error) {\n            elizaLogger.error(\"Error fetching portfolio:\", error);\n            throw error;\n        }\n    }\n\n    async fetchAllTokens(): Promise<Array<Item>> {\n        try {\n            const cacheKey = \"all-bera-tokens\";\n            const cachedValue = this.cache.get<Array<Item>>(cacheKey);\n            if (cachedValue) {\n                elizaLogger.log(\"Cache hit for fetch all\");\n                return cachedValue;\n            }\n            elizaLogger.log(\"Cache miss for fetch all\");\n\n            const fetchUrl = \"https://tokens.coingecko.com/berachain/all.json\";\n\n            const tokensResp = await fetch(fetchUrl);\n            const tokensData = await tokensResp.json();\n            if (!tokensData || tokensData.error || !tokensData.data) {\n                elizaLogger.error(\"Failed to fetch all tokens:\", tokensData);\n                throw new Error(\n                    `Failed to fetch all tokens: ${\n                        tokensData?.error || \"Unknown error\"\n                    }`\n                );\n            }\n\n            const tokens: Array<Item> =\n                tokensData.tokens.map(\n                    (item: TokenApiItem): Item => ({\n                        name: item.name,\n                        address: item.address as Address,\n                        symbol: item.symbol,\n                        decimals: item.decimals,\n                    })\n                ) || [];\n\n            this.cache.set(cacheKey, tokens);\n            return tokens;\n        } catch (error) {\n            elizaLogger.error(\"Error fetching all tokens:\", error);\n            throw error;\n        }\n    }\n}\n\nexport const initWalletProvider = async (runtime: IAgentRuntime) => {\n    const privateKey = runtime.getSetting(\"BERACHAIN_PRIVATE_KEY\");\n    const rpcUrl = runtime.getSetting(\"BERACHAIN_RPC_URL\");\n\n    if (!privateKey || !rpcUrl) {\n        throw new Error(\n            \"BERACHAIN_PRIVATE_KEY OR BERACHAIN_RPC_URL is missing\"\n        );\n    }\n    return new WalletProvider(privateKey, rpcUrl);\n};\n\nexport const walletProvider: Provider = {\n    get: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        state?: State\n    ): Promise<WalletProviderResponse> => {\n        try {\n            const walletProvider = await initWalletProvider(runtime);\n            const agentName = state?.agentName || \"The agent\";\n            return {\n                message: `${agentName}'s wallet address: ${walletProvider.getAddress()}`,\n            };\n        } catch (error) {\n            console.error(\"Error in wallet provider:\", error);\n            return {\n                message: \"Failed to get wallet address\",\n                error: error instanceof Error ? error.message : \"Unknown error\",\n            };\n        }\n    },\n};\n","import { type IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const berachainEnvSchema = z.object({\n    BERACHAIN_PRIVATE_KEY: z\n        .string()\n        .min(1, \"berachain plugin requires private key\"),\n    BERACHAIN_RPC_URL: z.string().min(1, \"berachain plugin requires rpc url\"),\n});\n\nexport type berachainConfig = z.infer<typeof berachainEnvSchema>;\n\nexport async function validateBerachainConfig(\n    runtime: IAgentRuntime\n): Promise<berachainConfig> {\n    try {\n        const config = {\n            BERACHAIN_PRIVATE_KEY:\n                runtime.getSetting(\"BERACHAIN_PRIVATE_KEY\") ||\n                process.env.BERACHAIN_PRIVATE_KEY,\n            BERACHAIN_RPC_URL:\n                runtime.getSetting(\"BERACHAIN_RPC_URL\") ||\n                process.env.BERACHAIN_RPC_URL,\n        };\n        return berachainEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(errorMessages);\n        }\n        throw error;\n    }\n}\n","export const HOLDSTATION_ROUTER_ADDRESS =\n    \"0x7d55d31adfde09f48d35cfca13c08a31ebc790cb\";\nexport const NATIVE_ADDRESS = \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n","import {\n    type Action,\n    type IAgentRuntime,\n    type Memory,\n    type HandlerCallback,\n    type State,\n    composeContext,\n    ModelClass,\n    elizaLogger,\n    type ActionExample,\n    generateObjectDeprecated,\n} from \"@elizaos/core\";\n\nimport { transferTemplate } from \"../templates\";\nimport type {\n    SendTransactionParams,\n    TransferParams,\n    TransferResult,\n} from \"../types\";\nimport {\n    initWalletProvider,\n    type WalletProvider,\n} from \"../providers/walletProvider\";\nimport { validateBerachainConfig } from \"../environment\";\nimport { Hex, isAddress, parseUnits } from \"viem\";\nimport { NATIVE_ADDRESS } from \"../constants\";\n\nexport class TransferAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async transfer(params: TransferParams): Promise<TransferResult> {\n        const { items: tokens } = await this.walletProvider.fetchPortfolio();\n\n        if (!params.inputTokenCA && !params.inputTokenSymbol) {\n            throw new Error(\"Input token not provided\");\n        }\n\n        if (!isAddress(params.recipient)) {\n            throw new Error(\"Invalid recipient address\");\n        }\n\n        const filters = tokens.filter((t) => {\n            return params.inputTokenCA\n                ? t.address === params.inputTokenCA\n                : t.symbol === params.inputTokenSymbol?.toUpperCase();\n        });\n        if (filters.length !== 1) {\n            throw new Error(\n                \"Multiple tokens or no tokens found with the symbol\"\n            );\n        }\n\n        // fill in token info\n        params.inputTokenCA = filters[0].address;\n        params.inputTokenSymbol = filters[0].symbol;\n        const decimals = filters[0].decimals ?? 18;\n\n        // parse amount out\n        const tokenAmount = parseUnits(params.amount, decimals);\n\n        elizaLogger.info(\"--- Transfer params:\", params, tokenAmount);\n\n        let hash: Hex;\n        if (params.inputTokenCA != NATIVE_ADDRESS) {\n            hash = await this.walletProvider.transfer(\n                params.inputTokenCA,\n                tokenAmount,\n                params.recipient\n            );\n        } else {\n            hash = (await this.walletProvider.sendTransaction({\n                to: params.recipient,\n                value: tokenAmount,\n                nonce: await this.walletProvider.getNonce(),\n            } as SendTransactionParams)) as Hex;\n        }\n\n        return {\n            hash,\n            ...params,\n        };\n    }\n}\n\nexport const transferAction: Action = {\n    name: \"TOKEN_TRANSFER\",\n    description: \"Perform transfering tokens on Berachain.\",\n    similes: [\n        \"TRANSFER_TOKEN\",\n        \"TOKEN_TRANSFER_ON_BERACHAIN\",\n        \"SEND_TOKENS\",\n        \"SEND_TOKENS_ON_BERACHAIN\",\n    ],\n    validate: async (\n        runtime: IAgentRuntime,\n        _message: Memory\n    ): Promise<boolean> => {\n        await validateBerachainConfig(runtime);\n        return true;\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting Berachain TOKEN_TRANSFER handler...\");\n\n        const walletProvider = await initWalletProvider(runtime);\n        const action = new TransferAction(walletProvider);\n\n        // Initialize or update state\n        let currentState =\n            state ?? ((await runtime.composeState(message)) as State);\n        if (state) {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // compose transfer context\n        const transferContext = composeContext({\n            state: currentState,\n            template: transferTemplate,\n        });\n\n        // generate transfer content\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: transferContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        elizaLogger.info(\"generate transfer content:\", content);\n\n        try {\n            const { hash, inputTokenCA, inputTokenSymbol, amount, recipient } =\n                await action.transfer(content);\n\n            const successMessage = `Transfer completed successfully ${amount} ${inputTokenSymbol} (${inputTokenCA}) to address ${recipient}!\\nTransaction Hash: ${hash}`;\n            elizaLogger.success(successMessage);\n\n            callback?.({\n                text: successMessage,\n                content: {\n                    success: true,\n                    hash: hash,\n                },\n            });\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error during token transfer:\", error);\n            const errorMessage =\n                error instanceof Error ? error.message : \"Unknown error\";\n\n            callback?.({\n                text: `Error during token transfer: ${errorMessage}`,\n                content: { error: errorMessage },\n            });\n\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1 BERA to 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Sure, I'll do send 1 BERA to 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785 now.\",\n                    action: \"TOKEN_TRANSFER\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Transfer completed 1 BERA to 0x708a4472eD832c54a76b30Ae247c33dDa1BF3785 successfully! Transaction: ...\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n","import { Plugin } from \"@elizaos/core\";\nimport { swapAction } from \"./actions/swapAction\";\nimport { transferAction } from \"./actions/transferAction\";\n\nexport const berachainPlugin: Plugin = {\n    name: \"berachain\",\n    description: \"Berachain Plugin for Eliza\",\n    actions: [swapAction, transferAction],\n    providers: [],\n    evaluators: [],\n};\n\nexport default berachainPlugin;\n"],"mappings":"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","names":["elizaLogger","tokens","filters","elizaLogger","composeContext","ModelClass","elizaLogger","generateObjectDeprecated","parseUnits","parseUnits","elizaLogger","composeContext","generateObjectDeprecated","ModelClass"]}